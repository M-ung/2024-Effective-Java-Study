# ν‘μ¤€ ν•¨μν• μΈν„°νμ΄μ¤λ¥Ό μ‚¬μ©ν•λΌ
> μλ°”8 λ¶€ν„° λλ‹¤λ¥Ό μ§€μ›ν•λ©΄μ„, APIλ¥Ό μ‘μ„±ν•λ” λ¨λ²” μ‚¬λ΅€λ“¤λ„ ν¬κ² λ°”λ€μ—λ‹¤. μμ‹λ΅, μƒμ„ ν΄λμ¤μ κΈ°λ³Έ λ©”μ„λ“λ¥Ό μ¬μ •μν•΄ μ›ν•λ” λ™μ‘μ„ κµ¬ν„ν•λ” ν…ν”λ¦Ώ λ©”μ„λ“ ν¨ν„΄μ„ λ³΄μ.

## π“ ν…ν”λ¦Ώ λ©”μ„λ“ ν¨ν„΄
```java
abstract class Cook {
    public void cooking() {
        System.out.println("μμ‹ μ΅°λ¦¬ μ‹μ‘");
        variant();
        System.out.println("μμ‹ μ΅°λ¦¬ μ™„λ£");
    }
    
    // λ³€ν™”ν•λ” λ¶€λ¶„
    abstract void variant();
}

class Baking extends Cook {
	@override
    public void variant() {
     	...
    }
}
```

## π“ λλ‹¤ μ‚¬μ©
```java
public class Cook {
     public void cooking(Strategy strategy) {
        System.out.println("μμ‹ μ΅°λ¦¬ μ‹μ‘");
        strategy.variant();
        System.out.println("μμ‹ μ΅°λ¦¬ μ™„λ£");
    }
}
```
```java
Cook.cooking(() -> (System.out.println("λΌλ©΄ λ“μ΄λ”μ¤‘");));
```

## π“ ν•¨μν• μΈν„°νμ΄μ¤ μμ‹
`LinkedHashMap` μ„ μλ΅ λ“¤μ–΄λ³΄μ.
`removeEldestEntry()` ν•¨μλ” λ§µμ— μƒλ΅μ΄ ν‚¤λ¥Ό μ¶”κ°€ν• λ•μΈ `put()` λ©”μ„λ“μ— μν•΄ νΈμ¶λλ”λ°, ν•΄λ‹Ή λ©”μ„λ“κ°€ `true` λ¥Ό λ°ν™ν•λ©΄ λ§µμ—μ„ κ°€μ¥ μ¤λλ μ›μ†λ¥Ό μ κ±°ν•λ‹¤.

<br>
λλ‹¤λ¥Ό μ‚¬μ©ν•μ§€ μ•λ” κ²½μ°λ” μ•„λμ™€ κ°™λ‹¤. <br>

```java
protected boolean removeEldestEntry(Map.Entry<K,V> eldest){
	return size() > 100;  
}
```

<br>
ν•¨μν• μΈν„°νμ΄μ¤ λλ‹¤λ¥Ό μ‚¬μ©ν• κ²½μ°λ” μ•„λμ™€ κ°™λ‹¤. <br>

```java
@FunctionalInterface interface EldestEntryRemovalFunction<K,V>{
	boolean remove(Map<K,V> map, Map.Entry<K,V> eldest); 
}
```
ν•μ§€λ§ μ΄λ―Έ μλ°” ν‘μ¤€ λΌμ΄λΈλ¬λ¦¬μ— κ°™μ€ λ¨μ–‘μ μΈν„°νμ΄μ¤κ°€ μ΅΄μ¬ν•λ‹¤. <br>

```
@FunctionalInterface
μ§μ ‘ λ§λ“  ν•¨μν• μΈν„°νμ΄μ¤λ” ν•΄λ‹Ή μ–΄λ…Έν…μ΄μ…μ΄ λ°λ“μ‹ μ΅΄μ¬ν•΄μ•Ό ν•λ‹¤.

1. ν•΄λ‹Ή ν΄λμ¤μ μ½”λ“λ‚ λ¬Έμ„λ¥Ό μ½μ„ μ΄μ—κ² μΈν„°νμ΄μ¤κ°€ λλ‹¤μ©μΌλ΅ μ„¤κ³„λ κ²ƒμ„μ„ μ•λ ¤μ¤€λ‹¤.
2. ν•΄λ‹Ή μΈν„°νμ΄μ¤κ°€ μ¶”μƒ λ©”μ„λ“λ¥Ό μ¤μ§ ν•λ‚λ§ κ°€μ§€κ³  μμ–΄μ•Ό μ»΄νμΌ λκ² ν•΄μ¤€λ‹¤.
3. μ μ§€λ³΄μ κ³Όμ •μ—μ„ λ„κµ°κ°€ μ‹¤μλ΅ λ©”μ„λ“λ¥Ό μ¶”κ°€ν•μ§€ λ»ν•κ² λ§‰μ•„μ¤€λ‹¤.
```

<br>
ν‘μ¤€ ν•¨μν• μΈν„°νμ΄μ¤λ¥Ό μ‚¬μ©ν• κ²½μ°λ” μ•„λμ™€ κ°™λ‹¤. <br>

```java
@FunctionalInterface
public interface BiPredicate<T, U> {
    boolean test(T t, U u);
}
```
```java
BiPredicate<Map<String, String>, Map.Entry<String, String>> predicate
     = (k, v) -> k.size() > 100;
```

ν•„μ”ν• μ©λ„μ— λ§λ”κ² μλ‹¤λ©΄ μ§μ ‘ κµ¬ν„ν•μ§€ λ§κ³  ν‘μ¤€ ν•¨μν• μΈν„°νμ΄μ¤λ¥Ό ν™μ©ν•λ” κ²ƒμ΄ μΆ‹λ‹¤.

## π“ ν•¨μν• μΈν„°νμ΄μ¤ μ£Όμμ‚¬ν•­
μ„λ΅ λ‹¤λ¥Έ ν•¨μν• μΈν„°νμ΄μ¤λ¥Ό κ°™μ€ μ„μΉμ μΈμλ΅ λ°›λ” λ©”μ„λ“λ“¤μ„ λ‹¤μ¤‘ μ •μν•΄μ„λ” μ•λλ‹¤. <br>
μ•„λμ™€ κ°™μ΄ `Callable` κ³Ό `Runnable` ν•¨μν• μΈν„°νμ΄μ¤λ¥Ό λ‹¤μ¤‘ μ •μν• κ²ƒμ„ λ³Ό μ μλ‹¤.

## β­οΈ ν•µμ‹¬ μ •λ¦¬

```
μ΄μ  μλ°”λ„ λλ‹¤λ¥Ό μ§€μ›ν•λ‹¤. μ…λ ¥κ°’κ³Ό λ°ν™κ°’μ— ν•¨μν• μΈν„°νμ΄μ¤ νƒ€μ…μ„ ν™μ©ν•λΌ.
λ³΄ν†µμ€ java.util.function ν¨ν‚¤μ§€μ ν‘μ¤€ ν•¨μν• μΈν„°νμ΄μ¤λ¥Ό μ‚¬μ©ν•λ” κ²ƒμ΄ κ°€μ¥ μΆ‹μ€ μ„ νƒμ΄λ‹¤.
λ‹¨, ν”μΉλ” μ•μ§€λ§ μ§μ ‘ μƒλ΅μ΄ ν•¨μν• μΈν„°νμ΄μ¤λ¥Ό λ§λ“¤μ–΄ μ“°λ” νΈμ΄ λ‚μ„ μλ„ μλ‹¤.
```
