# 스트림 병렬화는 주의해서 적용하라.

</br>

## 자바에서 병렬 처리 방식
(자바 5 ~) 자바에 동시성 컬렉션 `java.util.concurrent` 라이브러리 실행자(Executor) 프레임워크 지원

(자바 7 ~) 고성능 병렬 분해 프레임워크인 `fork-join` 패키지

(자바 8 ~) parallel 메서드만 한 번 호출하면 파이프라인을 병렬 실행할 수 있는 스트림을 지원

</br>

### 사용하는 코드 

```java
public static void main(String [] args) {
	primes().map(p -> TWO.pow(p.intValueExact()).subtract(ONE))
		.filter(mersenne -> marsenne.isProbablePrime(50))
		.limit(20)
		.forEach(Sysrem.out::println);
}

static Stream<BigInteger> primes() {
	return Stream.iterate(TWO, BigInteger::nextProbablePrime);
}
```
> 그냥 실행 : 12.1초

> 스트림 파이프라인의 parallel 로 병렬처리 실행 : 연산이 끝나지 않으면서 CPU는 90% 나 잡아먹는 상태가 무한히 계속된다

</br>

성능 개선을 위해서 병렬 스트림을 사용했는데 자바에서 파이프라인을 병렬화할 방법을 찾지 못해 문제가 발생한다.
- 환경이 아무리 좋다고 해도 데이터 소스가 `Stream.iterate` 거나 중간 연산자로 `limit` 을 사용하면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.

파이프라인 병렬화는 limit 이 있을때, CPU 코어가 남는다면 원소를 몇 개 더 처리한 후 제한된 개수 이후의 결과를 버려도 아무런 해가 없다고 가정한다.
- 원소 하나를 계산하는 비용이 대략 그 이전까지의 원소 전부를 계산한 비용을 합친 것만큼 든다.
- 계속해서 버려지면서 자동 병렬화 알고리즘이 제 기능을 못하게 마비되게 한다.

</br>

### 병렬 스트림과 limit() 상호작용 문제 정리

1. 병렬 스트림 동작 방식
- Java 에서 병렬 스트림을 사용하면 스트림의 요소들이 여러 CPU 코어에서 병렬로 처리된다.
- 스트림의 각 요소는 별도의 쓰레드에서 독립적으로 처리될 수 있으며, 이로 인해 전체 작업의 속도가 빨라질 수 있다.

</br>

2. limit() 의 동작 방식
- limit(n) 은 스트림의 앞쪽에서 최대 n개의 요소만을 처리하고, 그 이후의 요소들은 무시한다.
- 만약 limit(20) 이라면 스트림에 첫 20개의 요소만을 결과로 사용

</br>

3. 병렬 스트림과 limit() 의 상호작용 문제
- 병렬 스트림은 기본적으로 가능한 많은 요소를 병렬로 처리하려고 하지만, limit() 은 앞 쪽의 n개의 요소만을 처리하기 때뭉네 병렬화가 비효율적으로 동작할 수 있다.
- 메르센 소수를 계산하는데는 비용이 매우 큰데, 메르센 소수의 후보를 계산하는 비용이 이전에 계산된 모든 후보를 합친것 보다 크다고 가정하게 된다면 불필요한 계산은 배우 비효율적이다.
- 병렬화로 인해 여러 코어에서 이와 같은 비싼 계산을 병렬로 수행하고, 그 중 대부분이 limit() 에 의해 버려지게 되기 때문에 시스템 자원이 낭비된다.
- 결국 병렬로 계산된 결과의 대부분이 버려지게 된다면 실제로 불필요한 결과를 얻기 위해 계속해서 더 많은 계산을 수행해야 하며 성능에 해가 될 수 있다.


</br>

## 병렬 스트림은 언제 사용할 수 있을까?

</br>

스트림의 소스가 `ArrayList`, `HashMap`, `HashSet`, `ConcurrentHashMap`의 인스턴스거나 `배열`, `int 범위`, `long 범위`일 때 병렬화의 효과가 가장 좋다.

</br>

이웃한 원소의 참조들이 메모리에 연속해서 저장되어 참조 지역성이 높기 떄문이다.
- 참조 지역성이 낮게 된다면? 스레드는 데이터가 주 메모리에서 캐시 메모리로 전송되어 오기를 기다리며 시간을 보낸다.
- 기본 타입 배열인 경우 참조가 아닌 데이터 자체가 메모리에 연속해서 저장되기 때문에 참조 지역성이 제일 좋다.

</br>

데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어서 스레드에 분배하기 좋다.
- 나누는 작업은 `Spliterator` 가 담당하며 Stream 이나 Iterable 의 spliterator 메서드로 얻을 수 있다.
- Iterator 와 유사하게 요소를 순차적으로 탐색할 수 있는 기능을 제공하지만, 주로 병렬 처리에 최적화되어있다.


</br>


## 스트림 파이프라인의 종단 연산

종단 연산에서 수행하는 작업량이 파이프라인 전체 작업에서 상당 비중을 차지하면서 순차적인 연산인 경우 병렬 수행의 효과가 제한된다.

종단 연산 중 병렬화에 가장 적합한 것은 `축소(reduction)`다.
- 완선 형태로 제공되는 메서드 (min , max , count , sum)
- 조건에 맞으면 바로 반환하는 메서드 (anyMatch ,  allMatch , noneMatch)
- Stream 의 collect 메서드는 컬렉션들을 합치는 부담이 크기 때문에 병렬화에 적합하지 않다.

</br>

## 주의 사항
- spliterator() 를 반드시 재정의하고 스트림의 병렬화 성능을 강도높게 테스트한 후에 병렬화를 적용해야 한다.
- Stream의 reduce 연산에 건제니는 accumulator 와 combiner 함수는 반드시 결합 법칙을 지켜야 하며, 간섭 받지 않아야 하고, 상태를 갖지 않아야 한다.
- 파이프라인이 수행하는 진짜 작업이 병렬화에 드는 추가 비용을 상쇄하지 못한다면 성능 향상은 미미하다.


</br>

## 정리

</br>

- 확신 없이는 스트림 파이프라인 병렬화는 시도조차 하지 말자.

</br>

- 스트림을 잘못 병렬화하면 프로그램을 오작동하게 하거나 성능을 급격하게 떨어뜨린다.

</br>

- 운영 환경과 유사한 조건에서 수행해보며 성능지표를 유심히 관찰하고 확실하면 사용하자.
