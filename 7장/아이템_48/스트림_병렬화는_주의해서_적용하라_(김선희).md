# 스트림 병렬화는 주의해서 적용하라

## 스레드...동시성...병렬화...단어들을 정리해보자~
### 스레드란?
: 프로세스 안에서 실질적으로 작업을 실행하는 단위를 말하며 **Java는 JVM에 의해 관리**됩니다

* Main 스레드 하나로 시작하여 스레드를 추가하게 되면 멀티 스레드 환경이 됩니다
    * **`멀티 스레드`** 란 **main 함수가 실행되는 동안에도 다른 스레드를 동시에 실행하는 것**입니다. **Thread 클래스**를 사용해서 스레드를 생성할 수 있습니다

</br>

### 동시성이란?
: **싱글 코어에서 멀티 스레드를 동작시키기 위한 방식**으로, **여러 개의 스레드가 번갈아가면서 실행되는 것**

</br>

### 병렬화란?
: **멀티 코어에서 멀티 스레드를 동작시키는 방식**으로, **한 개 이상의 스레드를 포함하는 각 코어들이 동시에 실행되는 것**

</br>

## 자바의 동시성
* `java.util.concurrent` 를 지원하고 있고, **wait/notify** 를 지원하고 있다
* 스트림에서는 `parallel()`을 통해 **손쉽게 동시성을 제공**하고 있다

</br>

## 메르센 소수로 parallel() 사용해보기
```java
public void mersenne() {
    primes()
            .map(p -> TWO.pow(p.intValueExact()).subtract(ONE))
            .filter(mersenne -> mersenne.isProbablePrime(50))
            .limit(20)
            .forEach(mp -> System.out.println(mp.bitLength() + ": " + mp));
}
```

* 20번째까지 구하는 메서드이다
* 여기서는 **`parallel() 를 사용하지 않고 구현`**했다

</br>

만약 **`성능을 향상시키려고 parallel() 을 사용하면`** 아래와 같이 코드를 작성할 수 있는데

```java
public void mersenne() {
    primes()
            .parallel()
            .map(p -> TWO.pow(p.intValueExact()).subtract(ONE))
            .filter(mersenne -> mersenne.isProbablePrime(50))
            .limit(20)
            .forEach(mp -> System.out.println(mp.bitLength() + ": " + mp));
}
```
이렇게 하면 연산이 끝나지 않는다..!!

</br>

* `primes() 메서드` : 무한한 소수의 스트림을 반환합니다. 무한 스트림은 끝이 없기 때문에 모든 요소를 처리하는 작업은 무한히 계속됩니다
* `.parallel() 메서드` : 스트림을 병렬로 처리하게 만듭니다. 병렬 자체가 문제가 되지 않지만, 병렬 작업이 끝나지 않으면 CPU 사용량을 많이 차지할 수 있으며, 디버깅이 더 어려울 수 있습니다
* `.limit() 메서드` : 20개의 요소로 스트림을 제한하지만, 스트림의 소수가 무한적으로 제공되기 떄문에 조건에 알맞은 20개의 소수를 찾기 위해 계속해서 연산을 수행합니다

</br>

> ### 💡 여기서 주의해야 할 내용은 스트림을 사용해서 성능을 올리고 싶을 때, 아무렇게나 병렬화하면 성능이 훨씬 나빠진다는 점이다

</br>

## 병렬화를 언제 적용해야 할까?
### 원하는 크기로 데이터를 쪼갤 수 있을 때
`ArrayList`, `HashMap`, `HashSet`, `배열` 등 **범위를 쪼개기 쉬운 자료구조**에 있어 병렬을 진행하기 좋다

WHY?
→ **데이터를 원하는 크기로 쪼개기 쉽기 때문에** 스레드를 분배하기 좋다.

</br>

### 참조 지역성이 좋을 때
원소들을 순차적으로 실행할 때, **참조 지역성이 좋다는 것**이다.

#### WHY?
→ 이웃한 원소의 참조들이 **메모리에 연속해서 저장되어 있다는 것**이다.

</br>

### 축소 연산을 사용할 때
축소 연산은 **모든 원소를 합치는 작업**을 하는 연산이므로 **병렬화에 가장 적합**하다.

#### WHEN?
→ `min`, `max`, `count`, `sum` 과 같은 완**성된 형태의 메서드들을 사용할 때**

→ `anyMatch`, `allMatch`, `noneMatch` 처럼 **조건에 맞으면 바로 반환되는 메서드**

#### BUT!
`Stream`과 `collect 메서드`는 **병렬화에 적합하지 않다**

#### WHY?
**컬렉션들을 합치는데 부담이 크기 때문**이다

</br>

### 🤔 그럼 여기서 참조 지역성이 가장 좋은 자료구조는 무엇일까?
답은 **배열**이다

</br>

## 병렬화의 효과를 보는 코드
```java
public long pi(long n) {
    return LongStream.range(2, n)
            .parallel()
            .mapToObj(BigInteger::valueOf)
            .filter(i -> i.isProbablePrime(50))
            .count();
}
```

* 위 코드는 **`parallel() 메서드의 효과를 보는 코드`**이다
* 범위를 일정부분씩 쪼개 나눌 수 있기 때문이다

</br>

## 🎯 정리
* 아무렇게나 병렬화를 하면 **속도가 전혀 빨라지지 않는다**
* 병렬화 시 부작용, 즉 **속도나 효율성이 개선되었는지 고려해야 한다**