# 변경 가능성을 최소화하라.

</br>

> 불변 클래스는 쉽게 말해 내부 값을 수정할 수 없는 클래스이다.

</br>

</br>

## 클래스를 불변으로 만들기 위한 다섯가지 규칙

</br>

1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다.
3. 모든 필드를 final로 선언한다.
4. 모든 필드를 private으로 선언한다.
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록한다.

</br>

</br>

## 불변 객체의 장점

</br>

1. 단순하다.
2. 근본적으로 스레드 안전하여 따로 동기화할 필요가 없다.
3. 안심하고 공유할 수 있다.
4. 자유롭게 공유할 수 있고, 불변 객체끼리는 내부 데이터를 공유할 수 있다.
5. 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하며 이점이 많다.
6. 그 자체로 실패 원자성을 제공한다.

</br>

</br>

## 불변 객체의 단점

</br>

### 값이 다르면 반드시 독립된 객체로 만들어야 한다.

</br>

- 값이 변경될 때마다 새로운 객체를 생성해야 하기 때문에, 메모리 사용량이 증가할 수 있다.
- 빈번하게 객체를 생성하므로 가비지 컬렉션이 동작해 성능 저하로 이어질 수 있다.

</br>

</br>

### 이를 대처하기 위해 2가지 방법을 활용할 수 있다.

</br>

1. 흔히 쓰일 다단계 연산들을 기본 기능으로 제공한다.
    
    → 모듈러 지수 연산과 같은 다단계 연산을 사용하면 각 단계마다 객체를 생성하지 않아도 된다. (또는 `StringBuilder`와 같은 가변 동반 클래스 제공)
    
2. 모든 생성자를 `private` 혹은 `package-private`으로 만들고 `public 정적 팩터리`를 제공한다.
   
</br>
 
    
```java
    public class Complex {
        private final double re;
        private final double im;
    		
    		private Complex(double re, double im) {
            this.re = re;
            this.im = im;
        }
        
        public static Complex valueOf(double re, double im) {
            return new Complex(re, im);
        }
    }
```
    
  위와 같이 구현하면 패키지 바깥의 클라이언트에서 이 객체는 사실상 `final`이다.
    
</br>

  ### 왜일까?
    
</br>

  각 필드도 `private final` 이라 패키지 바깥에서 접근할 수 없고,생성자 자체가 `private` 이기 때문에 다른 패키지에서는 객체 생성 자체를 할 수 없기 때문이다.
    

</br>

</br>

## 정리

1. 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.
    - 웬만하면 불변 클래스가 특정 상황에서의 성능 저하 말고는 장점이 많다.
    - 성능 저하 때문에 어쩔 수 없다면 `가변 동반 클래스`를 public 클래스로 제공하도록 하자.

1. 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.
    - 객체가 가질 수 있는 상태의 수를 줄일 수록 오류가 생길 가능성이 줄어든다.
    - 그러니 꼭 변경해야 할 필드를 뺀 나머지 모두를 `final`로 선언하자. (스프링에서는 `의존성 주입`을 떠올려보자)
