# 필요 없는 검사 예외 사용은 피하라

## 예외 상황을 대처하는 예시
```java
try {
  // ...
} catch (TheCheckedException e) {
  throw new AssertionError(); // 일어날 수 없다!
}
```

```java
try {
  // ...
} catch (TheCheckedException e) {
  e.printStackTrace(); // 이런, 우리가 졌다!
  System.exit(1);
}
```

`검사 예외`를 저런 방식으로 처리할 바엔, `비검사 예외`로 처리하자!

</br>

## 검사 예외를 회피하는 방법 1 : 옵셔널
* 적절한 결과 타입을 담은 옵셔널을 반환하기
* 검사 예외를 던지지 말고 빈 옵셔널을 반환하기
    * 이 경우 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다
* 예외를 사용하면 구체적인 예외 타입과 그 타입이 제공하는 메서드들을 활용해 부가 정보를 제공할 수 있다

→ 이 부분 무슨말인지 이해하지 못함

</br>

## 검사 예외를 회피하는 방법 2 : 메서드를 2개로 쪼개기
* 메서드를 2개로 쪼개 비검사 예외로 변경할 수 있다
* 예외가 던져질지 여부를 boolean 값으로 반환

```java
// 리팩토링 전 코드
try {
  obj.action(args);
} catch (TheCheckedException e) {
  // 예외 복구
}
```

</br>

```java
// 리팩토링 후 코드
if(obj.actionPermitted(args)) {
  obj.action(args);
} else {
  // 예외 복구
}
```

* 모든 코드를 이렇게 리팩토링 할 수는 없지만, 적용할 수 있으면 사용하기 간편한 API 를 제공할 수 있다
* 리팩토링 후 코드가 더 보기 좋은 코드는 아니어도, 훨씬 유연하다

</br>

## 🎯 정리
* 꼭 필요한 곳에만 사용한다면 `검사 예외`는 프로그램의 안전성을 높여준다
* 남용하면 사용하기 불편한 API가 되버린다
* **예외 상황을 복구할 수 없다면** `비검사 예외`를 던지자
* **복구가 가능하고 처리할 수 있다면** `옵셔널`을 반환해도 되는지 고민하자
* `옵셔널`만으로는 처리하기 힘들다면 `검사 예외`를 던지자
