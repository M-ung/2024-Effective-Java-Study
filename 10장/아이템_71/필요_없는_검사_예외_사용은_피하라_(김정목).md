# 필요 없는 검사 예외 사용은 피하라.
> 검사 예외를 잘 활용하면 프로그램의 안정성과 질을 높일 수 있다. 하지만 검사 예외를 과하게 사용하면 오히려 사용하기 불편한 API가 될 수 있다.

## 📌 검사 예외와 비검사 예외 선택 기준
API를 제대로 사용해도 발생할 수 있는 예외거나, 프로그래머가 의미 있는 조치를 취할 수 있는 경우라면 검사 예외를 그렇지 않다면 비검사 예외를 사용하는 것이 좋다.

## 📌 검사 예외 회피 방법 - 비검사 예외
```java
// 비검사 예외를 호출한다.
} catch (TheCheckedException e) { 
    throw new AssertionError();  
}
```

```java
// 에러 스택 코드를 출력하고 시스템을 종료한다.
} catch (TheCheckedException e) {
    e.printStackTrace();
    System.exit(1);
}
```

위 코드를 보면 처음부터 비검사 예외로 만들었으면 더 좋았을 것이다. <br>

## 📌 검사 예외 회피 방법 - Optional
메서드가 단 하나의 검사 예외만 던질 때 API 사용자의 부담은 더욱 커진다. 단 하나의 검사 예외를 위해 `try` 블록을 추가해야 하고 스트림에서 메서드를 직접 사용하지 못하게 된다. <br>
따라서 이런 상황이라면 검사 예외를 안던지는 방법을 고려해야 한다. <br>

그중 가장 쉽게 검사 예외를 회피하는 방법이 Optional을 반환하는 것이다.  <br>
검사 예외를 던지는 대신 빈 옵셔널을 반환하면 된다. 다만, 예외가 발생한 이유에 대한 부가 정보를 담을 수 없다는 단점이 있다.  <br>

반면, 예외를 사용하면 구체적인 예외 타입이나 그 타입이 제공하는 메서드들을 활용해 부가 정보를 제공할 수 있다. <br>


## 📌 검사 예외 회피 방법 - 메서드 쪼개기
```java
// before - 검사 예외를 던지는 메서드
try {
    Obj.action(args);    
} catch (TheCheckedException e) {
    // 예외 상황에 대처하는 로직
}
```

```java
// after - 상태 검사 메서드와 비검사 예외를 던지는 메서드
if (obj.actionPermitted(args)) {
    obj.action(args);
} else {
    // 예외 상황에 대처하는 로직
}
```

위 적용을 모든 상황에 적용할 수는 없겠지만, 적용할 수 있다면 더 쓰기 편한 API를 제공할 수 있다. <br>

## ⭐️ 핵심 정리
```
꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안전성을 높여주지만, 남용하면 쓰기 고통스러운 API를 낳는다.
API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자.
복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자.
옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없 때만 검사 예외를 던지자.
```
